require('dotenv').config();

const express = require('express');
const cors = require('cors');
const path = require('path');
const { Pool } = require('pg');
const OpenAI = require('openai');
const MCDCore = require('./mcd-core');

// ‚úÖ MERCADO PAGO (SDK v2)
const { MercadoPagoConfig, Preference } = require('mercadopago');

const MANUS_FREE = `
Voc√™ √© o MindKappa Analyst, a extens√£o l√≥gica do criador do projeto MCD (Medidor de Coer√™ncia Decisional). Sua miss√£o √© transformar dados estat√≠sticos complexos (Œ∫ - kappa) em insights humanos, positivos e profundos.
Regras:
- Tom: encorajador, cient√≠fico-acess√≠vel, com "UAU".
- Proibido jarg√µes (Œ∫, von Mises, ‚Äúcoer√™ncia‚Äù) no relat√≥rio gr√°tis.
- Use termos humanos: Equil√≠brio, Const√¢ncia, Flexibilidade, Foco, Resposta ao Tempo.
- Use emojis com modera√ß√£o (1 por t√≠tulo e 1 por bullet).
- An√°lise: Baseie sua an√°lise nos dados brutos e nas regras de Tipos Mentais fornecidas no Contexto.
- Estrutura obrigat√≥ria (nessa ordem):
  1) üß† O T√çTULO (A Revela√ß√£o)‚Ä¢
  2) üéØ O QUE VOC√ä FEZ (Tradu√ß√£o dos Dados)
  3) üîç O QUE DESCOBRIMOS SOBRE VOC√ä (O Insight Central)
  4) ‚≠ê SEUS SUPERPODERES MENTAIS
  5) üí° DICAS PARA O SEU DIA A DIA
  O relat√≥rio deve seguir esta estrutura exata, com o tom de voz definido.
  SE√á√ÉO 1: O T√çTULO (A Revela√ß√£o)‚Ä¢
  T√≠tulo: Use o Tipo Mental descoberto. Ex: "Sua Mente: A Executora Perfeita"
  Subt√≠tulo: Uma frase de impacto. Ex: "Voc√™ √© extraordin√°ria em transformar inten√ß√µes em resultados exatos." 

  SE√á√ÉO 2: O QUE VOC√ä FEZ (Tradu√ß√£o dos Dados)
  Objetivo: Traduzir os 3 testes para linguagem humana.
  Formato: Use o formato de lista para clareza.
  Teste Aleat√≥rio: (Descreva o resultado) Ex: "Sua mente tem uma paix√£o forte pelo vermelho"
  Teste 50/50: (Descreva o resultado) Ex: "Precis√£o absoluta! Voc√™ atingiu o objetivo com perfei√ß√£o"
  Teste Prefer√™ncia: (Descreva o resultado) Ex: "Totalmente comprometida com sua decis√£o"

  SE√á√ÉO 3: O QUE DESCOBRIMOS SOBRE VOC√ä (O Insight Central)
  O bjetivo: Explicar o Tipo Mental com profundidade e tom positivo.
  Conte√∫do: Conecte os 3 resultados em uma √∫nica narrativa.
  Exemplo: "Sua mente √© uma obra-prima de disciplina. Voc√™ consegue ser apaixonada, mas quando tem um objetivo, sua capacidade de autocontrole √© perfeita."

  SE√á√ÉO 4: SEUS SUPERPODERES MENTAIS
  Objetivo: Lista de 3-4 pontos fortes que o usu√°rio pode usar na vida real.
  Exemplo: Precis√£o Absoluta: Voc√™ atinge metas com exatid√£o.
  Autocontrole Estrat√©gico: Voc√™ se disciplina quando √© importante.
  Comprometimento Total: Quando voc√™ decide, voc√™ vai at√© o fim.

  SE√á√ÉO 5: DICAS PARA O SEU DIA A DIA
  Objetivo: 3-4 conselhos pr√°ticos baseados no Tipo Mental.
  Exemplo: "Use sua precis√£o em projetos que exijam detalhes. Confie no seu autocontrole para resistir a distra√ß√µes."

  SE√á√ÉO 7: MENSAGEM FINAL
  Objetivo: Encerramento com alto impacto emocional.
  Exemplo: "Continue sendo essa pessoa [Tipo Mental] que voc√™ √©! Seu [Ponto Forte] √© um superpoder valioso!"
  6) üöÄ Pr√≥ximo passo (convite gentil ao Premium: Analise completa em PDF, dicas personalizadas para o dia-a-dia, melhora criatividade, foco etc., compara√ß√µes)
  - Tamanho: 180‚Äì1200 palavras, direto e sem floreio.

Tipos Mentais (heur√≠stica):
- Executora Perfeita: "aleat√≥rio" alto, "50/50" perfeito, "prefer√™ncia" alto.
- Aleat√≥rio Natural: "aleat√≥rio" perfeito/quase, "50/50" um pouco menos preciso.
- Racional Equilibrado: "aleat√≥rio" baixo/m√©dio, "50/50" perfeito, "prefer√™ncia" alto.
- Mestre do Equil√≠brio: "aleat√≥rio" baixo/perfeito e "50/50" perfeito.
- Apaixonado Controlado: "aleat√≥rio" alto, "50/50" perfeito, "prefer√™ncia" alto.
- Equilibrista Absoluta: "50/50" perfeito e "prefer√™ncia" ~50/50.
- Apaixonado Disciplinado: "aleat√≥rio" alto, "50/50" quase perfeito, "prefer√™ncia" alto.
- Equilibrista Determinado: "aleat√≥rio" baixo/m√©dio, "50/50" quase perfeito, "prefer√™ncia" alto.
- Aut√™ntica Consistente: "aleat√≥rio" m√©dio, "50/50" levemente alto, "prefer√™ncia" alto.
- Aleat√≥rio Criativo (Lion): Œ∫ m√©dio muito baixo; variabilidade extrema.
`;

// PREMIUM: quadro de Tipos Mentais e compara√ß√£o populacional (pode usar Œ∫ nos bastidores)
const MANUS_PREMIUM = `
Voc√™ √© o MindKappa Analyst (vers√£o Premium).
Objetivo: classificar Tipo Mental com base nas 3 dimens√µes e comparar com popula√ß√£o.
Regras de estilo:
- Tom: forte, inspirador, t√©cnico-acess√≠vel. Emojis moderados.
- No texto final, n√£o exagere em n√∫meros brutos; traduza Œ∫ em linguagem humana (pode citar, mas priorize significado).

Tipos Mentais (heur√≠stica):
- Executora Perfeita: "aleat√≥rio" alto, "50/50" perfeito, "prefer√™ncia" alto.
- Aleat√≥rio Natural: "aleat√≥rio" perfeito/quase, "50/50" um pouco menos preciso.
- Racional Equilibrado: "aleat√≥rio" baixo/m√©dio, "50/50" perfeito, "prefer√™ncia" alto.
- Mestre do Equil√≠brio: "aleat√≥rio" baixo/perfeito e "50/50" perfeito.
- Apaixonado Controlado: "aleat√≥rio" alto, "50/50" perfeito, "prefer√™ncia" alto.
- Equilibrista Absoluta: "50/50" perfeito e "prefer√™ncia" ~50/50.
- Apaixonado Disciplinado: "aleat√≥rio" alto, "50/50" quase perfeito, "prefer√™ncia" alto.
- Equilibrista Determinado: "aleat√≥rio" baixo/m√©dio, "50/50" quase perfeito, "prefer√™ncia" alto.
- Aut√™ntica Consistente: "aleat√≥rio" m√©dio, "50/50" levemente alto, "prefer√™ncia" alto.
- Aleat√≥rio Criativo (Lion): Œ∫ m√©dio muito baixo; variabilidade extrema.

Compara√ß√£o Populacional:
- Œ∫ m√©dio populacional (Primeiros10): 10.476
- Œ∫ m√©dio Lion: 0.413
Diretrizes:
- Se Œ∫ m√©dio usu√°rio < 1.0, destaque ‚Äúmais aleat√≥rio que a m√©dia‚Äù.
- Se ‚Äú50/50‚Äù ~perfeito, destacar precis√£o quase perfeita.
Estrutura Premium:
1) T√≠tulo (Tipo Mental)
2) O que voc√™ fez (3 testes + contagens)
3) Insight central (narrativa √∫nica)
4) Superpoderes mentais (3‚Äì4 bullets)
5) Compara√ß√£o com mundo (raridade/benchmark)
6) Dicas aplic√°veis (3‚Äì4)
7) Mensagem final forte
`;

// ‚úÖ cria o client com o access token do .env
const mpClient = new MercadoPagoConfig({
  accessToken: process.env.MERCADOPAGO_ACCESS_TOKEN
});

async function gerarSystemPrompt() {
  return `
Voc√™ √© o "MindKappa Analyst" ‚Äî a extens√£o l√≥gica e pedag√≥gica do projeto MCD (Medidor de Coer√™ncia Decisional).
Miss√£o: transformar dados do MCD em um Relat√≥rio Premium que impressione (tom positivo, cient√≠fico e acess√≠vel).
REGRAS:
- Tom: encorajador e inspirador, mas neutro e N√ÉO-DIAGN√ìSTICO.
- N√ÉO use jarg√µes t√©cnicos (Œ∫, von Mises) no corpo do relat√≥rio; prefira termos humanos: Equil√≠brio, Paix√£o, Precis√£o, Autocontrole.
- Estrutura obrigat√≥ria do relat√≥rio (em portugu√™s, pt-BR):
  1) T√≠tulo / Revela√ß√£o com Tipo Mental
  2) O que voc√™ fez (resumo dos 3 testes)
  3) O que descobrimos (insight central)
  4) Seus superpoderes mentais (3-4 pontos)
  5) Compara√ß√£o com a popula√ß√£o (usar valores populacionais fornecidos)
  6) Dicas pr√°ticas (3-4 conselhos curtos)
  7) Mensagem final inspiradora
- Traduza n√∫meros em linguagem humana (ex.: "voc√™ √© X vezes mais aleat√≥rio que a m√©dia") e explique a raridade.
- Propor 3 exerc√≠cios pr√°ticos (1-2 linhas cada).
- Evitar avalia√ß√µes m√©dicas ou linguagem cl√≠nica.
- Responder em Portugu√™s (pt-BR).
`;
}



function montarUserMessagePremium(userData) {
  const nome = userData.name || 'Explorador';
  const t1 = userData.teste1 || {};
  const t2 = userData.teste2 || {};
  const t3 = userData.teste3 || {};

  const azuis1 = Number(t1.statistics?.blueCount || 0);
  const vermelhos1 = Number(t1.statistics?.redCount || 0);
  const azuis2 = Number(t2.statistics?.blueCount || 0);
  const vermelhos2 = Number(t2.statistics?.redCount || 0);
  const azuis3 = Number(t3.statistics?.blueCount || 0);
  const vermelhos3 = Number(t3.statistics?.redCount || 0);

  const k1 = Number.isFinite(Number(t1.coherence?.kappa)) ? Number(t1.coherence.kappa) : NaN;
  const k2 = Number.isFinite(Number(t2.coherence?.kappa)) ? Number(t2.coherence.kappa) : NaN;
  const k3 = Number.isFinite(Number(t3.coherence?.kappa)) ? Number(t3.coherence.kappa) : NaN;

  const kValues = [k1, k2, k3].filter(v => !Number.isNaN(v));
  const kMedia = kValues.length ? (kValues.reduce((s,v)=>s+v,0) / kValues.length).toFixed(3) : "N/A";

  // Estat√≠sticas populacionais (exemplo ‚Äî ajuste se tiver n√∫meros diferentes)
  const kPopMedia = 10.476;
  const kLion = 0.413;

  return `
DADOS DO USU√ÅRIO:
NOME: ${nome}
TESTE 1 (Instinto): ${azuis1} AZUL / ${vermelhos1} VERMELHO | Œ∫1 = ${Number.isNaN(k1) ? 'N/A' : k1.toFixed(3)}
TESTE 2 (Equil√≠brio): ${azuis2} AZUL / ${vermelhos2} VERMELHO | Œ∫2 = ${Number.isNaN(k2) ? 'N/A' : k2.toFixed(3)}
TESTE 3 (Press√£o): ${azuis3} AZUL / ${vermelhos3} VERMELHO | Œ∫3 = ${Number.isNaN(k3) ? 'N/A' : k3.toFixed(3)}
Œ∫ M√âDIO: ${kMedia}

DADOS POPULACIONAIS:
Œ∫ m√©dio populacional (Primeiros10): ${kPopMedia}
Œ∫ m√©dio do criador (Lion): ${kLion}

INSTRU√á√ïES:
1) Classifique o usu√°rio em um Tipo Mental com base nos Œ∫s.
2) Gere o Relat√≥rio PREMIUM seguindo a estrutura do system prompt.
3) Traduza m√©tricas em linguagem humana (Equil√≠brio, Paix√£o, Precis√£o) ‚Äî sem termos t√©cnicos.
4) Proponha 3 exerc√≠cios pr√°ticos (1-2 linhas cada).
5) Tom: inspirador, n√£o-diagn√≥stico. Linguagem: Portugu√™s.
6) Tamanho: detalhado (m√°ximo de tokens permitido).
`;
}

const app = express();

// ‚úÖ CORS (liberado para dev; pode travar por dom√≠nio depois)
app.use(cors({ origin: true, credentials: true }));

// ‚úÖ JSON body
app.use(express.json());

// ‚úÖ Servir est√°ticos do frontend (/public)
app.use(express.static(path.join(__dirname, '..', 'public')));

// (Opcional) cache leve para assets
app.use((_, res, next) => {
  res.setHeader('Cache-Control', 'public, max-age=300');
  next();
});

app.get('/healthz', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    service: 'mindkappa-backend',
    version: '1.0.0'
  });
});

// ‚úÖ CONFIGURA√á√ïES CONTROLADAS (INTERRUPTORES)
const OPENAI_ENABLED = process.env.OPENAI_ENABLED === 'true';
const OPENAI_TIMEOUT = parseInt(process.env.OPENAI_TIMEOUT) || 10000;

console.log('üîß Configura√ß√µes Seguras:', {
  OPENAI_ENABLED,
  OPENAI_TIMEOUT
});

// ‚úÖ CONEX√ÉO COM BANCO
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

// ‚úÖ OPENAI (SE CONFIGURADO)
let openai;
if (process.env.OPENAI_API_KEY && OPENAI_ENABLED) {
  openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
  console.log('‚úÖ OpenAI configurado (controlado)');
} else {
  console.log('üîÑ OpenAI desligado por configura√ß√£o');
}

// ‚úÖ HEALTH CHECK
app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    openai_enabled: OPENAI_ENABLED,
    timestamp: new Date().toISOString()
  });
});

// ‚úÖ SALVAR DADOS
app.post('/api/save-research-data', async (req, res) => {
  try {
    const { userData } = req.body;
    console.log('üíæ Salvando dados para:', userData?.name);

    const result = await pool.query(
      `INSERT INTO mindkappa_sessions1 (user_data) VALUES ($1) RETURNING id`,
      [userData]
    );

    console.log('‚úÖ Dados salvos! ID:', result.rows[0].id);

    res.json({ success: true, sessionId: result.rows[0].id });
  } catch (error) {
    console.error('‚ùå Erro ao salvar:', error.message);
    res.json({ success: true, sessionId: 'mk-' + Date.now(), fallback: true });
  }
});

// ‚úÖ C√ÅLCULO DE COER√äNCIA COM MCD CORE
app.post('/api/calculate-coherence', async (req, res) => {
  try {
    const { choices, testType, sessionId } = req.body;

    console.log(`üß† Calculando coer√™ncia: ${testType}, ${choices.length} escolhas`);

    MCDCore.validateChoices(choices);
    const report = MCDCore.generateReport(choices);

    let dbResult;
    try {
      dbResult = await pool.query(
        `INSERT INTO mindkappa_coherence (session_id, test_type, choices, kappa_value, r_value, coherence_level) 
         VALUES ($1, $2, $3, $4, $5, $6) RETURNING id`,
        [sessionId, testType, choices, report.kappa, report.R, report.coherenceLevel]
      );
      console.log('‚úÖ Coer√™ncia salva no BD:', dbResult.rows[0].id);
    } catch (dbError) {
      console.log('üìù Coer√™ncia calculada (n√£o salva no BD):', dbError.message);
    }

    res.json({
      success: true,
      testType: testType || 'unknown',
      sessionId: sessionId || 'anonymous',
      coherence: {
        kappa: report.kappa,
        level: report.coherenceLevel,
        description: report.description,
        emoji: report.emoji,
        color: report.color
      },
      statistics: report.statistics,
      metrics: { R: report.R, N: report.N, timestamp: report.timestamp },
      savedToDb: !!dbResult
    });
  } catch (error) {
    console.error('‚ùå Erro no c√°lculo de coer√™ncia:', error);
    res.status(400).json({ success: false, error: error.message, timestamp: new Date().toISOString() });
  }
});

app.post('/api/update-user-coherence', async (req, res) => {
  try {
    const { userData } = req.body;
    console.log('üîÑ Atualizando userData com coer√™ncia...');

    const updatedUserData = JSON.parse(JSON.stringify(userData)); // deep copy

    // Teste 1
    if (userData.teste1?.decisions) {
      const choices = userData.teste1.decisions.map(d => d.choice === 'azul' ? 'Azul' : 'Vermelho');
      MCDCore.validateChoices(choices);
      const report = MCDCore.generateReport(choices);

      updatedUserData.teste1.coherence = {
        kappa: report.kappa,
        level: report.coherenceLevel,
        description: report.description,
        emoji: report.emoji,
        color: report.color
      };
      updatedUserData.teste1.statistics = report.statistics;
    }

    // Teste 2
    if (userData.teste2?.decisions) {
      const choices = userData.teste2.decisions.map(d => d.choice === 'azul' ? 'Azul' : 'Vermelho');
      MCDCore.validateChoices(choices);
      const report = MCDCore.generateReport(choices);

      updatedUserData.teste2.coherence = {
        kappa: report.kappa,
        level: report.coherenceLevel,
        description: report.description,
        emoji: report.emoji,
        color: report.color
      };
      updatedUserData.teste2.statistics = report.statistics;
    }

    // Teste 3
    if (userData.teste3?.decisions) {
      const choices = userData.teste3.decisions.map(d => d.choice === 'azul' ? 'Azul' : 'Vermelho');
      MCDCore.validateChoices(choices);
      const report = MCDCore.generateReport(choices);

      updatedUserData.teste3.coherence = {
        kappa: report.kappa,
        level: report.coherenceLevel,
        description: report.description,
        emoji: report.emoji,
        color: report.color
      };
      updatedUserData.teste3.statistics = report.statistics;
    }

    res.json({ success: true, updatedUserData });
  } catch (error) {
    console.error('‚ùå Erro ao atualizar coer√™ncia:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// ‚úÖ RELAT√ìRIO PREMIUM
app.post('/api/generate-premium-report', async (req, res) => {
  try {
    const { userData, sessionId } = req.body;
    console.log('üíé Gerando relat√≥rio premium para:', userData?.name);

    console.log('üîç Dados recebidos para an√°lise premium:', {
      temTeste1: !!userData?.teste1,
      temTeste2: !!userData?.teste2,
      temTeste3: !!userData?.teste3,
      coerenciaTeste1: userData?.teste1?.coherence,
      coerenciaTeste2: userData?.teste2?.coherence,
      coerenciaTeste3: userData?.teste3?.coherence
    });

    let relatorioPremium = null;
    let source = 'fallback_premium';

    if (OPENAI_ENABLED && openai) {
      try {
        const systemPrompt = await gerarSystemPrompt();
        const userPrompt = gerarPromptPremiumV2(userData);

        const messages = [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ];

        const completion = await Promise.race([
          openai.chat.completions.create({
            model: "gpt-3.5-turbo",
            messages,
            max_tokens: 1100,
            temperature: 0.6
          }),
          new Promise((_, reject) => setTimeout(() => reject(new Error('OpenAI timeout')), OPENAI_TIMEOUT))
        ]);

        relatorioPremium = completion.choices?.[0]?.message?.content || null;

        if (relatorioPremium) {
          source = 'gpt35_premium';
          console.log('‚úÖ GPT gerou relat√≥rio premium. tamanho:', relatorioPremium.length);
        } else {
          console.log('‚ö†Ô∏è GPT retornou vazio, usando fallback.');
        }
      } catch (openaiError) {
        console.warn('‚ùå OpenAI erro (premium):', openaiError.message);
      }
    } else {
      console.log('‚ÑπÔ∏è OpenAI desligado ou n√£o configurado ‚Äî usando fallback.');
    }

    if (!relatorioPremium) {
      relatorioPremium = gerarFallbackPremium(userData);
      source = source === 'gpt35_premium' ? source : 'fallback_premium';
      console.log('‚ÑπÔ∏è Usando fallback premium.');
    }

    try {
      const dbResult = await pool.query(
        `INSERT INTO mindkappa_premium_reports (session_id, user_name, report_content, generated_at) 
         VALUES ($1, $2, $3, $4) RETURNING id`,
        [sessionId, userData?.name, relatorioPremium, new Date().toISOString()]
      );
      console.log('üíæ Relat√≥rio premium salvo no BD:', dbResult.rows[0].id);
    } catch (dbError) {
      console.log('üìù Relat√≥rio premium n√£o salvo no BD:', dbError.message);
    }

    return res.json({ success: true, relatorio: relatorioPremium, source, tipo: 'premium' });
  } catch (error) {
    console.error('‚ùå Erro cr√≠tico no relat√≥rio premium:', error);
    res.status(500).json({ success: false, error: 'Erro ao gerar relat√≥rio premium' });
  }
});

function gerarPromptGratuito(userData) {
  const nome = userData?.name || 'Explorador';

  const t1 = userData?.teste1 || {};
  const t2 = userData?.teste2 || {};
  const t3 = userData?.teste3 || {};

  // Contagens (AZUL/VERMELHO)
  const a1 = Number(t1.statistics?.blueCount || 0);
  const v1 = Number(t1.statistics?.redCount || 0);
  const a2 = Number(t2.statistics?.blueCount || 0);
  const v2 = Number(t2.statistics?.redCount || 0);
  const a3 = Number(t3.statistics?.blueCount || 0);
  const v3 = Number(t3.statistics?.redCount || 0);

  // Equil√≠brio simples 0‚Äì100 (%)
  const bal = (a, v) => {
    const tot = a + v;
    if (!tot) return 0;
    const dev = Math.abs(a - v);
    return Math.round((1 - dev / tot) * 100);
  };
  const bal1 = bal(a1, v1); // instinto
  const bal2 = bal(a2, v2); // equil√≠brio
  const bal3 = bal(a3, v3); // press√£o

  // Altern√¢ncia no Teste 2
  let alternancias2 = 0;
  if (Array.isArray(t2.decisions) && t2.decisions.length > 1) {
    for (let i = 1; i < t2.decisions.length; i++) {
      const prev = t2.decisions[i - 1]?.choice;
      const cur  = t2.decisions[i]?.choice;
      if (prev && cur && prev !== cur) alternancias2++;
    }
  }
  const total2 = (a2 + v2) || (t2.decisions?.length || 0);
  const alternanciaRate2 = total2 > 1 ? Math.round((alternancias2 / (total2 - 1)) * 100) : 0;

  // Press√£o temporal (timeouts + tempo m√©dio de rea√ß√£o v√°lido)
  let timeouts3 = 0, somaRT3 = 0, contRT3 = 0;
  if (Array.isArray(t3.decisions)) {
    for (const d of t3.decisions) {
      if (d.timedOut) timeouts3++;
      if (!d.timedOut && Number.isFinite(d.reactionTime)) {
        somaRT3 += d.reactionTime; contRT3++;
      }
    }
  }
  const timeoutRate3 = (t3.decisions && t3.decisions.length)
    ? Math.round((timeouts3 / t3.decisions.length) * 100)
    : 0;
  const avgRT3s = contRT3 ? Math.round((somaRT3 / contRT3) / 100) / 10 : 0; // seg., 1 casa

  // pistas heur√≠sticas para narrativa (n√£o imprimir as palavras)
  const pistaInstinto   = (a1 + v1 === 0) ? 'sem_dados' : (bal1 >= 70 ? 'equilibrado' : (a1 > v1 ? 'pref_azul' : 'pref_vermelho'));
  const pistaEquilibrio = (a2 + v2 === 0) ? 'sem_dados' : (bal2 >= 75 ? 'equilibrado' : (a2 > v2 ? 'puxa_azul' : 'puxa_vermelho'));
  const pistaPressao    = (a3 + v3 === 0) ? 'sem_dados' :
    ((timeoutRate3 <= 20 && bal3 >= 60) ? 'mantem_equilibrio' : (a3 > v3 ? 'pressao_azul' : 'pressao_vermelho'));

  return `
${MANUS_FREE}

DADOS:
‚Ä¢ Nome: ${nome}
‚Ä¢ Teste 1 (Instinto): ${a1} AZUL / ${v1} VERMELHO
‚Ä¢ Teste 2 (Equil√≠brio): ${a2} AZUL / ${v2} VERMELHO
‚Ä¢ Teste 3 (Press√£o): ${a3} AZUL / ${v3} VERMELHO

SINAIS (usar na narrativa, n√£o como tabela):
‚Ä¢ Equil√≠brio % ‚Äî Instinto: ${bal1} | Equil√≠brio: ${bal2} | Press√£o: ${bal3}
‚Ä¢ Altern√¢ncia no Teste 2: ${alternancias2} (~${alternanciaRate2}%)
‚Ä¢ Press√£o ‚Äî timeouts: ${timeouts3} (${timeoutRate3}%), tempo m√©dio: ~${avgRT3s}s
‚Ä¢ Pistas: instinto=${pistaInstinto}, equilibrio=${pistaEquilibrio}, pressao=${pistaPressao}

SA√çDA:
- 180‚Äì1200 palavras, 2¬™ pessoa, pt-BR.
- T√≠tulos com 1 emoji; bullets com 1 emoji.
- Explique os 3 testes com as contagens e traduza os sinais em experi√™ncia humana.
- Proibido jarg√µes t√©cnicos (Œ∫ etc).
- Inclua ‚ÄúPr√≥ximo passo‚Äù convidando ao Premium (IA + PDF + compara√ß√µes).
`;
}

function gerarPromptPremiumV2(userData) {
  const nome = userData?.name || 'Explorador';
  const t1 = userData?.teste1 || {};
  const t2 = userData?.teste2 || {};
  const t3 = userData?.teste3 || {};

  const a1 = Number(t1.statistics?.blueCount || 0);
  const v1 = Number(t1.statistics?.redCount || 0);
  const a2 = Number(t2.statistics?.blueCount || 0);
  const v2 = Number(t2.statistics?.redCount || 0);
  const a3 = Number(t3.statistics?.blueCount || 0);
  const v3 = Number(t3.statistics?.redCount || 0);

  const k1 = Number(t1.coherence?.kappa || 0);
  const k2 = Number(t2.coherence?.kappa || 0);
  const k3 = Number(t3.coherence?.kappa || 0);
  const kVals = [k1, k2, k3].filter(n => Number.isFinite(n));
  const kMed = kVals.length ? (kVals.reduce((s,v)=>s+v,0)/kVals.length) : 0;

  return `
${MANUS_PREMIUM}

DADOS:
‚Ä¢ Nome: ${nome}
‚Ä¢ Teste 1 (Instinto): ${a1} AZUL / ${v1} VERMELHO | Œ∫1 ‚âà ${k1.toFixed(3)}
‚Ä¢ Teste 2 (Equil√≠brio): ${a2} AZUL / ${v2} VERMELHO | Œ∫2 ‚âà ${k2.toFixed(3)}
‚Ä¢ Teste 3 (Press√£o): ${a3} AZUL / ${v3} VERMELHO | Œ∫3 ‚âà ${k3.toFixed(3)}
‚Ä¢ Œ∫ m√©dio (usu√°rio): ${kMed.toFixed(3)}
‚Ä¢ Œ∫ m√©dio (Popula√ß√£o Primeiros10): 10.476
‚Ä¢ Œ∫ m√©dio (Lion): 0.413

INSTRU√á√ïES:
- Classifique o Tipo Mental com base nas tr√™s dimens√µes (use as diretrizes ‚ÄúTipos Mentais‚Äù).
- Converta Œ∫ em linguagem humana (evite f√≥rmulas; pode citar Œ∫ pontualmente).
- Use a Estrutura Premium.
- Emojis moderados em t√≠tulos e bullets.
- Portugu√™s (Brasil).
`;
}

function gerarDicasPraticas(azuis1, vermelhos1, azuis2, vermelhos2, azuis3, vermelhos3) {
  const dicas = [];

  if (azuis1 === 0 || vermelhos1 === 0) {
    dicas.push("‚Ä¢ CONFIE NA SUA INTUI√á√ÉO - Quando voc√™ segue seu instinto, age com convic√ß√£o!");
  }

  if (Math.abs(azuis2 - vermelhos2) <= 2) {
    dicas.push("‚Ä¢ USE SEU TALENTO PARA EQUIL√çBRIO - Voc√™ √© √≥timo em encontrar meio-termo em discuss√µes!");
  }

  if (azuis3 === 0 || vermelhos3 === 0) {
    dicas.push("‚Ä¢ EM MOMENTOS DECISIVOS - Lembre-se que voc√™ fica super focado sob press√£o, use isso a seu favor!");
  }

  if (dicas.length === 0) {
    dicas.push("‚Ä¢ EXPERIMENTE DIFERENTES ABORDAGENS - Sua mente se adapta bem a diversos contextos!");
    dicas.push("‚Ä¢ OBSERVE SEUS PADR√ïES - Preste aten√ß√£o em como voc√™ toma decis√µes no dia a dia!");
  }

  return dicas.join('\n');
}

function gerarMensagemFinal(nome) {
  const mensagens = [
    `${nome}, sua mente √© √∫nica e especial! Os padr√µes que descobrimos mostram caracter√≠sticas valiosas que voc√™ pode usar a seu favor!`,
    `${nome}, o teste revelou talentos mentais incr√≠veis! Continue explorando como sua mente funciona - o autoconhecimento √© um superpoder!`,
    `${nome}, cada mente √© uma obra de arte! A sua tem padr√µes fascinantes que merecem ser celebrados e usados com sabedoria!`
  ];

  return mensagens[Math.floor(Math.random() * mensagens.length)];
}

function gerarInsightTeste1(azuis, vermelhos) {
  const total = azuis + vermelhos;
  if (total === 0) return "Seu instinto est√° sendo analisado...";

  if (azuis === 0 || vermelhos === 0) {
    return "Quando voc√™ segue a intui√ß√£o, vai at√© o fim sem hesitar! Sua mente escolhe um caminho e segue com convic√ß√£o total!";
  }
  if (Math.abs(azuis - vermelhos) <= 2) {
    return "Seu instinto naturalmente busca equil√≠brio! Sua primeira rea√ß√£o j√° considera diferentes perspectivas de forma harmoniosa!";
  }
  if (azuis > vermelhos * 1.5) {
    return "Sua intui√ß√£o tem uma clara prefer√™ncia pelo azul! Quando voc√™ n√£o pensa muito, sua mente escolhe uma dire√ß√£o espec√≠fica!";
  }
  if (vermelhos > azuis * 1.5) {
    return "Sua intui√ß√£o tem uma clara prefer√™ncia pelo vermelho! Sua mente instintiva sabe exatamente o que quer!";
  }
  return "Sua primeira rea√ß√£o tem prefer√™ncias bem definidas, mas com espa√ßo para varia√ß√£o!";
}

function gerarInsightTeste2(azuis, vermelhos) {
  const total = azuis + vermelhos;
  if (total === 0) return "Seu equil√≠brio est√° sendo analisado...";

  const diferenca = Math.abs(azuis - vermelhos);

  if (diferenca === 0) {
    return "PERFEITO! Quando voc√™ tenta equilibrar, consegue com precis√£o absoluta! Sua mente √© uma balan√ßa perfeita!";
  }
  if (diferenca <= 2) {
    return "Excelente! Voc√™ tem um talento natural para encontrar equil√≠brio! Sua mente busca harmonia de forma consistente!";
  }
  if (diferenca <= 5) {
    return "Voc√™ se esfor√ßa pelo equil√≠brio, mas suas prefer√™ncias pessoais ainda aparecem! Isso mostra autenticidade!";
  }
  return "Mesmo tentando equilibrar, suas inclina√ß√µes naturais s√£o fortes! Isso revela personalidade bem definida!";
}

function gerarInsightTeste3(azuis, vermelhos) {
  const total = azuis + vermelhos;
  if (total === 0) return "Sua performance sob press√£o est√° sendo analisada...";

  if (azuis === 0 || vermelhos === 0) {
    return "SOB PRESS√ÉO, voc√™ se torna super focado! Sua mente escolhe uma dire√ß√£o e segue com determina√ß√£o total, sem distra√ß√µes!";
  }
  if (Math.abs(azuis - vermelhos) <= 3) {
    return "Inc√≠vel! Mesmo sob press√£o, voc√™ mant√©m o equil√≠brio! Sua mente funciona bem mesmo em situa√ß√µes desafiadoras!";
  }
  if (azuis > vermelhos) {
    return "Sob press√£o, sua mente se inclina fortemente para o azul! O estresse traz √† tona suas prefer√™ncias mais profundas!";
  }
  return "Sob press√£o, sua mente se inclina fortemente para o vermelho! Situa√ß√µes intensas revelam seu lado mais decisivo!";
}

function gerarPerfilMental(nome, azuis1, vermelhos1, azuis2, vermelhos2, azuis3, vermelhos3) {
  const perfis = [];

  const preferencia1 = azuis1 > vermelhos1 ? "AZUL" : "VERMELHO";
  const preferencia2 = azuis2 > vermelhos2 ? "AZUL" : "VERMELHO";

  if (preferencia1 !== preferencia2) {
    perfis.push(`MENTE ADAPT√ÅVEL - Voc√™ muda de estrat√©gia quando o contexto pede (de ${preferencia1} para ${preferencia2})`);
  }

  const diferenca1 = Math.abs(azuis1 - vermelhos1);
  const diferenca2 = Math.abs(azuis2 - vermelhos2);

  if (diferenca1 >= 7) {
    perfis.push("INTUI√á√ÉO FORTE - Seu instinto tem prefer√™ncias bem definidas");
  }

  if (diferenca2 >= 8) {
    perfis.push("PERSONALIDADE MARCADA - Mesmo tentando equilibrar, seu estilo √∫nico aparece");
  }

  const preferencia3 = azuis3 > vermelhos3 ? "AZUL" : "VERMELHO";
  if (preferencia2 === preferencia3) {
    perfis.push("FOCO SOB PRESS√ÉO - Sob estresse, voc√™ mant√©m a mesma dire√ß√£o que escolheu conscientemente");
  }

  if (perfis.length === 0) {
    perfis.push("EXPLORADOR √öNICO - Sua mente tem combina√ß√µes especiais que merecem ser descobertas");
  }

  return `${nome}, descobrimos que sua mente √© fascinante! \n\nSEU PERFIL: "${perfis[0]}"\n\nCOMO SUA MENTE FUNCIONA:\n‚Ä¢ ${perfis.join('\n‚Ä¢ ')}\n\nIsso revela padr√µes mentais muito interessantes!`;
}

// ‚úÖ RELAT√ìRIO GRATUITO (com fallback)
app.post('/api/generate-report', async (req, res) => {
  try {
    const { userData } = req.body;
    console.log('üß† Gerando relat√≥rio para:', userData?.name || 'Explorador');

    let relatorio, source;

    if (OPENAI_ENABLED && openai) {
      console.log('üîÑ Tentando OpenAI...');
      try {
        const completion = await Promise.race([
          openai.chat.completions.create({
            model: "gpt-3.5-turbo",
            messages: [
      {
        role: "system",
        content: "Voc√™ escreve relat√≥rios MindKappa no estilo MANUS. Siga estritamente o manual. Pro√≠ba termos t√©cnicos (Œ∫, von Mises). Tom n√£o-diagn√≥stico."
      },
      {
        role: "user",
        content: gerarPromptGratuito(userData)
      }
    ],
            max_tokens: 750,
            temperature: 0.7
          }),
          new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), OPENAI_TIMEOUT))
        ]);

        relatorio = completion.choices[0].message.content;
        source = 'openai';
        console.log('‚úÖ OpenAI funcionou!');
      } catch (openaiError) {
        console.log('üîÑ OpenAI falhou, usando fallback:', openaiError.message);
      }
    }

    if (!relatorio) {
      relatorio = `Relat√≥rio personalizado para ${userData?.name}. Seus 3 testes de padr√µes mentais foram analisados com sucesso! Padr√µes √∫nicos detectados.`;
      source = 'fallback';
    }

    res.json({ success: true, relatorio, source });
  } catch (error) {
    console.error('‚ùå Erro geral:', error);
    res.json({
      success: true,
      relatorio: 'An√°lise conclu√≠da. Seus dados foram processados com sucesso!',
      source: 'emergency_fallback'
    });
  }
});


// ‚úÖ MERCADO PAGO (Checkout Pro)
app.post('/api/simple-subscription', async (req, res) => {
  try {
    console.log('üîÑ Criando prefer√™ncia de pagamento (Checkout Pro)‚Ä¶');

    // --- NORMALIZA E VALIDA FRONTEND_URL ---
    const FRONTEND =
      (process.env.FRONTEND_URL && process.env.FRONTEND_URL.trim())
        ? process.env.FRONTEND_URL.trim().replace(/\/+$/, '') // remove barra final
        : 'http://localhost:3000';

    const isLocal = /^https?:\/\/localhost(:\d+)?$/i.test(FRONTEND);

    const backUrls = {
      success: `${FRONTEND}/success.html`,
      failure: `${FRONTEND}/failure.html`,
      pending: `${FRONTEND}/pending.html`
    };
    console.log('‚Ü©Ô∏è back_urls em uso:', backUrls);

    // seguran√ßa: exige protocolo http/https
    if (!/^https?:\/\//i.test(backUrls.success)) {
      throw new Error(`BACK_URL_INVALID: success="${backUrls.success}" ‚Äî verifique FRONTEND_URL no .env`);
    }

    // monta preference
    const preference = {
      items: [
        {
          id: 'premium-report',
          title: 'Relat√≥rio Premium MindKappa',
          description: 'An√°lise profunda do padr√£o decisional (PDF completo)',
          quantity: 1,
          unit_price: 9.9,
          currency_id: 'BRL'
        }
      ],
      back_urls: backUrls,
      statement_descriptor: 'MINDKAPPA'
      // n√£o force m√©todos de pagamento
    };

    // ‚ö†Ô∏è auto_return s√≥ em produ√ß√£o (URLs p√∫blicas https)
    if (!isLocal) {
      preference.auto_return = 'approved';
    } else {
      console.log('‚ÑπÔ∏è Ambiente local detectado ‚Äî auto_return desativado para evitar erro do MP.');
    }

    const preferenceClient = new Preference(mpClient);
    const response = await preferenceClient.create({ body: preference });

    // üîç LOG COMPLETO PARA VERMOS O FORMATO REAL
    console.log('üîé MP RAW response:\n', JSON.stringify(response, null, 2));

    // üß† Extra√ß√£o defensiva
    const raw = response || {};
    const prefId =
      raw.id ?? raw.body?.id ?? raw.response?.id ?? null;

    const initPoint =
      raw.init_point ??
      raw.body?.init_point ??
      raw.sandbox_init_point ??
      raw.body?.sandbox_init_point ??
      null;

    console.log('‚úÖ Prefer√™ncia criada (normalizada):', { id: prefId, init_point: initPoint });

    if (!prefId || !initPoint) {
      return res.status(500).json({
        success: false,
        error: 'Prefer√™ncia criada mas sem init_point/id no retorno',
        fallback: true,
        details: { prefId, initPoint, raw }
      });
    }

    return res.json({
      success: true,
      payment_link: initPoint,
      fallback: false,
      pix_data: null
    });

  } catch (error) {
    const details = error?.cause || error?.response || error?.message || error;
    console.error('‚ùå Erro Mercado Pago (Preference v2):', details);
    return res.status(500).json({
      success: false,
      error: 'Erro ao criar pagamento',
      fallback: true,
      details
    });
  }
});


function gerarPromptPremium(userData) {
  const t1 = userData.teste1;
  const t2 = userData.teste2;
  const t3 = userData.teste3;

  const nome = userData.name || 'Explorador';

  const azuis1 = t1?.statistics?.blueCount || 0;
  const vermelhos1 = t1?.statistics?.redCount || 0;
  const azuis2 = t2?.statistics?.blueCount || 0;
  const vermelhos2 = t2?.statistics?.redCount || 0;
  const azuis3 = t3?.statistics?.blueCount || 0;
  const vermelhos3 = t3?.statistics?.redCount || 0;

  const k1 = t1?.coherence?.kappa || 0;
  const k2 = t2?.coherence?.kappa || 0;
  const k3 = t3?.coherence?.kappa || 0;

  return `
CRIE UM RELAT√ìRIO PREMIUM **IMPRESSIOANTE** PARA ESTUDIOSOS DE COMPORTAMENTO:

DADOS COMPLETOS DO USU√ÅRIO:
‚Ä¢ NOME: ${nome}
‚Ä¢ TESTE 1 (Instinto): ${azuis1} azuis, ${vermelhos1} vermelhos | Œ∫ = ${k1.toFixed(3)}
‚Ä¢ TESTE 2 (Equil√≠brio): ${azuis2} azuis, ${vermelhos2} vermelhos | Œ∫ = ${k2.toFixed(3)}  
‚Ä¢ TESTE 3 (Press√£o): ${azuis3} azuis, ${vermelhos3} vermelhos | Œ∫ = ${k3.toFixed(3)}

INSTRU√á√ïES PARA RELAT√ìRIO **IMPRESSIOANTE**:

üß† AN√ÅLISE PROFUNDA DO PERFIL COGNITIVO
[Incluir an√°lise t√©cnica dos padr√µes Œ∫]

üìä MAPA VISUAL DE PADR√ïES  
[Descrever visualmente os 3 testes lado a lado]

üéØ DETEC√á√ÉO DE TEND√äNCIAS COMPORTAMENTAIS
[Identificar padr√µes espec√≠ficos: criatividade vs foco, Œ∫ alto vs baixo]

üí° EXERC√çCIOS COMPORTAMENTAIS PERSONALIZADOS
[Criar 3-4 exerc√≠cios baseados nos padr√µes detectados]

üî¨ BENCHMARK CIENT√çFICO
[Comparar com bases de pesquisa em tomada de decis√£o]

üìà ESTRAT√âGIAS DE OTIMIZA√á√ÉO COGNITIVA
[Baseado em Œ∫ alto/baixo para diferentes contexts]

ESTRUTURA OBRIGAT√ìTIA:
1. An√°lise T√©cnica Profunda
2. Padr√µes Detectados com Dados
3. Exerc√≠cios Pr√°ticos Personalizados  
4. Contexto Cient√≠fico
5. Estrat√©gias de Alto Impacto

N√çVEL: Estudosos de comportamento - linguagem t√©cnica mas acess√≠vel
TAMANHO: Extremamente detalhado (m√°ximo de tokens)
`;
}

// ‚úÖ FALLBACK PREMIUM
function gerarFallbackPremium(userData) {
  const t1 = userData.teste1;
  const t2 = userData.teste2;
  const t3 = userData.teste3;

  const nome = userData.name || 'Explorador';

  const azuis1 = t1?.statistics?.blueCount || 0;
  const vermelhos1 = t1?.statistics?.redCount || 0;
  const azuis2 = t2?.statistics?.blueCount || 0;
  const vermelhos2 = t2?.statistics?.redCount || 0;
  const azuis3 = t3?.statistics?.blueCount || 0;
  const vermelhos3 = t3?.statistics?.redCount || 0;

  return `üß† RELAT√ìRIO PREMIUM MINDKAPPA - ${nome}

üìä AN√ÅLISE AVAN√áADA DOS SEUS PADR√ïES DECISIONAIS

Seus dados de ${azuis1 + vermelhos1 + azuis2 + vermelhos2 + azuis3 + vermelhos3} escolhas revelam padr√µes fascinantes de comportamento decisional em diferentes contextos.

üìà SEUS RESULTADOS:
‚Ä¢ INSTINTO: ${azuis1} azuis, ${vermelhos1} vermelhos
‚Ä¢ EQUIL√çBRIO: ${azuis2} azuis, ${vermelhos2} vermelhos
‚Ä¢ PRESS√ÉO: ${azuis3} azuis, ${vermelhos3} vermelhos

üí° PADR√ïES IDENTIFICADOS:
Sua mente mostra caracter√≠sticas √∫nicas de adapta√ß√£o e consist√™ncia entre os diferentes contextos testados.

üéØ PR√ìXIMOS PASSOS:
Para uma an√°lise completa com IA avan√ßada, tente novamente em alguns minutos.

---
üõ°Ô∏è AVISO: Este √© um relat√≥rio educacional de autoconhecimento.
N√£o constitui avalia√ß√£o psicol√≥gica ou m√©dica.

MindKappa - Tecnologia para Autoconhecimento üß†`;
}

// ‚úÖ ROTAS MINDKAPPA LAB (MCD v2)

// Retorna permiss√£o e status do Lab
app.get('/api/lab-access', (req, res) => {
  try {
    res.json({
      success: true,
      version: '2.0',
      equation: 'Œ∫ = [R(2 - R¬≤)] / [(1 - R¬≤) + œÉ]',
      message: 'Acesso liberado ao MindKappa Lab ‚Ä¢ MCD v2 ativo üß†'
    });
  } catch (err) {
    res.status(500).json({ success: false, error: 'Erro no acesso ao Lab' });
  }
});

// Recebe e registra sess√£o do Lab
app.post('/api/save-lab-data', async (req, res) => {
  try {
    const { userData, labSession } = req.body;

    if (!labSession || !Array.isArray(labSession.decisions)) {
      return res.status(400).json({ success: false, error: 'Dados inv√°lidos do Lab' });
    }

    // c√°lculo redundante de seguran√ßa
    const thetas = labSession.decisions.map(d => d.choice === 'azul' ? 0 : Math.PI);
    const N = thetas.length;
    const sumCos = thetas.reduce((s, t) => s + Math.cos(t), 0);
    const sumSin = thetas.reduce((s, t) => s + Math.sin(t), 0);
    const R = Math.sqrt(sumCos ** 2 + sumSin ** 2) / N;
    const meanAngle = Math.atan2(sumSin, sumCos);
    const diffs = thetas.map(t => Math.atan2(Math.sin(t - meanAngle), Math.cos(t - meanAngle)));
    const sigma = Math.sqrt(diffs.reduce((s, t) => s + t ** 2, 0) / N);
    const kappa = (R * (2 - R ** 2)) / ((1 - R ** 2) + sigma);

    const safeUser = userData?.name || 'An√¥nimo';

    // salva no banco (opcional)
    try {
      const result = await pool.query(
        `INSERT INTO mindkappa_lab_sessions (user_name, decisions, r_value, sigma_value, kappa_value, created_at)
         VALUES ($1, $2, $3, $4, $5, NOW()) RETURNING id`,
        [safeUser, labSession.decisions, R, sigma, kappa]
      );
      console.log('üß† Nova sess√£o Lab salva:', result.rows[0].id);
    } catch (dbErr) {
      console.warn('‚ö†Ô∏è Erro ao salvar no banco:', dbErr.message);
    }

    res.json({
      success: true,
      message: 'Sess√£o do Lab salva com sucesso!',
      results: {
        user: safeUser,
        N,
        R: Number(R.toFixed(4)),
        sigma: Number(sigma.toFixed(4)),
        kappa: Number(kappa.toFixed(4))
      }
    });
  } catch (error) {
    console.error('‚ùå Erro ao salvar sess√£o do Lab:', error);
    res.status(500).json({ success: false, error: 'Erro ao processar sess√£o do Lab' });
  }
});

// Retorna estat√≠sticas gerais (ex: m√©dia global de Œ∫)
app.get('/api/lab-stats', async (req, res) => {
  try {
    const query = await pool.query(`
      SELECT 
        COUNT(*) as total,
        ROUND(AVG(kappa_value)::numeric, 4) as kappa_media,
        ROUND(AVG(r_value)::numeric, 4) as r_media,
        ROUND(AVG(sigma_value)::numeric, 4) as sigma_media
      FROM mindkappa_lab_sessions
    `);
    res.json({
      success: true,
      data: query.rows[0],
      message: 'üìä Estat√≠sticas globais do MindKappa Lab'
    });
  } catch (err) {
    console.error('Erro nas estat√≠sticas do Lab:', err.message);
    res.json({ success: false, error: 'Erro ao obter estat√≠sticas do Lab' });
  }
});


// ‚úÖ PORTA PADR√ÉO 3000 (alinha com FRONTEND_URL)
const PORT = process.env.PORT || 3000;

app.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ MindKappa Backend SEGURO rodando na porta ${PORT}`);
  console.log(`üß† MCD Core: ATIVO`);
  console.log(`üí≥ Mercado Pago: ${process.env.MERCADOPAGO_ACCESS_TOKEN ? 'PRONTO PARA PAGAMENTOS' : 'CONFIGURAR'}`);
  console.log(`ü§ñ OpenAI: ${OPENAI_ENABLED ? 'LIGADO' : 'DESLIGADO'}`);
  console.log(`üîó Frontend: ${process.env.FRONTEND_URL || 'http://localhost:3000'}`);
  console.log(`üìä Health: http://localhost:${PORT}/health`);
});

// ‚úÖ Catch-all final para servir HTML do /public sem afetar /api/*
app.get('*', (req, res, next) => {
  if (req.path.startsWith('/api')) return next();
  const file = req.path.endsWith('.html') ? req.path : '/index.html';
  res.sendFile(path.join(__dirname, '..', 'public', file));
});

// ‚úÖ MANTER PROCESSO ATIVO (graceful)
process.on('SIGTERM', () => {
  console.log('üîÑ Servidor recebeu SIGTERM, encerrando graciosamente...');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('üîÑ Servidor reiniciando...');
  process.exit(0);
});
