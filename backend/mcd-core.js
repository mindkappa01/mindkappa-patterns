/**
 * üß† MCD Core - MindKappa Proprietary Technology
 * ¬© 2025 MindKappa Labs. Todos os direitos reservados.
 * Uso comercial n√£o autorizado √© estritamente proibido.
 * 
 * M√≥dulo interno do sistema MindKappa para c√°lculo de coer√™ncia decisional.
 * Desenvolvido por Lion (N1) com base em estat√≠stica circular von Mises.
 * 
 * CONFIDENCIAL: Este c√≥digo n√£o deve ser compartilhado ou distribu√≠do.
 */

class MCDCore {
  /**
   * Calcula o par√¢metro Œ∫ de coer√™ncia decisional
   * @param {string[]} choices - Array de escolhas ('Azul' ou 'Vermelho')
   * @returns {Object} Resultado com N, R e kappa
   */
  static computeKappa(choices) {
    if (!choices || !Array.isArray(choices) || choices.length === 0) {
      throw new Error('Array de escolhas inv√°lido');
    }

    const thetas = choices.map(c => {
      if (c === 'Azul') return 0;
      if (c === 'Vermelho') return Math.PI;
      throw new Error(`Escolha inv√°lida: ${c}. Apenas "Azul" ou "Vermelho" s√£o permitidos.`);
    });

    const N = thetas.length;
    
    const sumCos = thetas.reduce((s, t) => s + Math.cos(t), 0);
    const sumSin = thetas.reduce((s, t) => s + Math.sin(t), 0);
    
    const R = Math.sqrt(sumCos**2 + sumSin**2) / N;
    
    // Prote√ß√µes num√©ricas para casos extremos
    if (R < 0.001) return { N, R: 0, kappa: 0 };
    if (R > 0.999) return { N, R: 1, kappa: 10 };
    
    const kappa = (R * (2 - R**2)) / (1 - R**2);
    
    return { 
      N, 
      R: parseFloat(R.toFixed(4)), 
      kappa: parseFloat(Math.min(kappa, 10).toFixed(4))
    };
  }

  /**
   * Interpreta o valor Œ∫ em n√≠veis de coer√™ncia
   * @param {number} kappa - Valor Œ∫ calculado
   * @returns {Object} Interpreta√ß√£o com n√≠vel, descri√ß√£o e cor
   */
  static interpretKappa(kappa) {
    if (kappa >= 1.0) return { 
      nivel: 'ALTA', 
      descricao: 'Padr√£o decisional muito consistente e direcional',
      cor: '#10b981',
      emoji: 'üéØ'
    };
    if (kappa >= 0.5) return { 
      nivel: 'MODERADA', 
      descricao: 'Padr√£o discern√≠vel com tend√™ncia clara',
      cor: '#f59e0b',
      emoji: 'üìä'
    };
    if (kappa >= 0.3) return { 
      nivel: 'BAIXA', 
      descricao: 'Tend√™ncia leve detect√°vel',
      cor: '#ef4444',
      emoji: 'üìà'
    };
    return { 
      nivel: 'ALEAT√ìRIA', 
      descricao: 'Padr√£o n√£o detect√°vel - decis√µes pr√≥ximas do aleat√≥rio',
      cor: '#6b7280',
      emoji: 'üé≤'
    };
  }

  /**
   * Valida o array de escolhas
   * @param {string[]} choices - Array de escolhas
   * @param {number} expectedLength - Comprimento esperado (opcional)
   * @returns {boolean} True se v√°lido
   */
  static validateChoices(choices, expectedLength = null) {
    if (!choices || !Array.isArray(choices)) {
      throw new Error('Array de escolhas √© obrigat√≥rio');
    }
    
    if (expectedLength && choices.length !== expectedLength) {
      throw new Error(`N√∫mero incorreto de escolhas: ${choices.length}, esperado: ${expectedLength}`);
    }
    
    const validChoices = choices.filter(c => c === 'Azul' || c === 'Vermelho');
    if (validChoices.length !== choices.length) {
      const invalid = choices.filter(c => c !== 'Azul' && c !== 'Vermelho');
      throw new Error(`Escolhas inv√°lidas detectadas: ${invalid.join(', ')}`);
    }
    
    return true;
  }

  /**
   * Gera relat√≥rio completo de coer√™ncia
   * @param {string[]} choices - Array de escolhas
   * @returns {Object} Relat√≥rio completo
   */
  static generateReport(choices) {
    this.validateChoices(choices);
    
    const { kappa, R, N } = this.computeKappa(choices);
    const interpretation = this.interpretKappa(kappa);
    
    const blueCount = choices.filter(c => c === 'Azul').length;
    const redCount = choices.filter(c => c === 'Vermelho').length;
    const bluePercentage = ((blueCount / N) * 100).toFixed(1);
    
    return {
      kappa,
      R,
      N,
      coherenceLevel: interpretation.nivel,
      description: interpretation.descricao,
      color: interpretation.cor,
      emoji: interpretation.emoji,
      statistics: {
        blueCount,
        redCount, 
        bluePercentage: `${bluePercentage}%`,
        redPercentage: `${(100 - bluePercentage).toFixed(1)}%`
      },
      timestamp: new Date().toISOString()
    };
  }
}

// Prote√ß√£o contra uso n√£o autorizado
if (typeof module !== 'undefined' && module.exports) {
  module.exports = MCDCore;
} else {
  console.warn('‚ö†Ô∏è  MCD Core - Uso n√£o autorizado detectado');
  console.warn('üîí Este m√≥dulo √© propriedade exclusiva da MindKappa Labs');
}

console.log('üß† MCD Core carregado - MindKappa Technology ¬© 2025');